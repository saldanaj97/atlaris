name: CI - Main (trunk)

on:
  push:
    branches: [main]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'specs/**'
      - '**/*.txt'
      - '**/*.csv'
      - '**/*.log'
  merge_group:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      integration: ${{ steps.filter.outputs.integration }}
      e2e: ${{ steps.filter.outputs.e2e }}
      migrations: ${{ steps.filter.outputs.migrations }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            integration:
              - 'src/**'
              - 'tests/integration/**'
              - 'vitest.config.ts'
              - 'tsconfig.json'
              - 'package.json'
              - 'pnpm-lock.yaml'
              - 'drizzle.config.ts'
            e2e:
              - 'src/**'
              - 'public/**'
              - 'tests/e2e/**'
              - 'vitest.config.ts'
              - 'tsconfig.json'
              - 'next.config.ts'
              - 'package.json'
              - 'pnpm-lock.yaml'
              - 'drizzle.config.ts'
            migrations:
              - 'src/lib/db/migrations/*.sql'
              - 'src/lib/db/migrations/meta/**'
              - 'src/lib/db/schema/**'
              - 'src/lib/db/enums.ts'
              - 'drizzle.config.ts'



  vulnerability-scan:
    name: Security Audit
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [changes]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
      - name: Run dependency audit
        run: pnpm audit --audit-level=high
        continue-on-error: true

  e2e-tests:
    name: E2E / Smoke Tests
    if: needs.changes.outputs.e2e == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [changes]
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4]
        total: [4]
    services:
      postgres:
        image: postgres:17
        ports:
          - '5432:5432'
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres -d postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
      - name: Setup pnpm store cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client
      - name: Prepare ephemeral database
        env:
          PGPASSWORD: postgres
        run: |
          # Wait for database readiness
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U postgres -d postgres; then break; fi
            sleep 1
          done

          DB_NAME="ci_${GITHUB_RUN_ID}_e2e_${{ matrix.shard }}_${GITHUB_JOB}"
          echo "DB_NAME=${DB_NAME}" >> $GITHUB_ENV
          psql -h localhost -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"${DB_NAME}\";"

          # Defensive bootstrap (idempotent)
          psql -h localhost -p 5432 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 <<'SQL'
          CREATE EXTENSION IF NOT EXISTS pgcrypto;
          DO $$ BEGIN CREATE ROLE anonymous NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE authenticated NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE neondb_owner NOINHERIT NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          CREATE SCHEMA IF NOT EXISTS auth;
          CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb
          LANGUAGE sql
          AS $$ SELECT COALESCE(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb) $$;
          SQL

          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/${DB_NAME}" >> $GITHUB_ENV
      - name: Apply schema with Drizzle (staging)
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ env.DATABASE_URL }}
        run: pnpm db:push:test-db
      - name: Grant RLS bypass and role permissions
        env:
          PGPASSWORD: postgres
        run: |
          # Grant BYPASSRLS to postgres user to allow direct test access
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 -c "ALTER ROLE postgres BYPASSRLS;"

          # Grant table permissions to authenticated role for RLS testing
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO authenticated;
          GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
          GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO authenticated;
          SQL

          # Grant read-only permissions to anonymous role
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO anonymous;
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO anonymous;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO anonymous;
          SQL
      - name: Restore Vitest cache
        uses: actions/cache/restore@v4
        id: restore-vitest-cache
        with:
          path: |
            node_modules/.vite
            node_modules/.vitest
          key: ${{ runner.os }}-vitest-${{ hashFiles('pnpm-lock.yaml') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-vitest-${{ hashFiles('pnpm-lock.yaml') }}-
      - name: Run E2E tests (Vitest shard ${{ matrix.shard }}/${{ matrix.total }})
        env:
          NODE_ENV: 'test'
          ALLOW_DB_TRUNCATE: 'true'
          DATABASE_URL: ${{ env.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ env.DATABASE_URL }}
          ENABLE_CURATION: 'false'
        run: |
          set -e
          FILES=$(find tests/e2e -type f \( -name "*.test.ts" -o -name "*.spec.ts" -o -name "*.test.tsx" -o -name "*.spec.tsx" \) | wc -l || echo 0)
          if [ "$FILES" -eq 0 ]; then
            echo "No E2E test files found; skipping."
            exit 0
          fi
          SHARD=${{ matrix.shard }}
          TOTAL=${{ matrix.total }}
          if [ "$SHARD" -gt "$FILES" ]; then
            echo "Shard $SHARD exceeds file count $FILES; skipping this shard."
            exit 0
          fi
          if [ "$FILES" -lt "$TOTAL" ]; then
            TOTAL="$FILES"
          fi
          pnpm vitest run --project e2e tests/e2e \
            --shard "$SHARD/$TOTAL" \
            --coverage \
            --coverage.thresholds.lines=0 \
            --coverage.thresholds.functions=0 \
            --coverage.thresholds.branches=0 \
            --coverage.thresholds.statements=0 \
            --reporter=default \
            --reporter=json \
            --outputFile=test-results.json
      - name: Generate test summary
        if: always()
        run: |
          if [ -f test-results.json ]; then
            echo "## üåê E2E Tests - Shard ${{ matrix.shard }}/${{ matrix.total }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Extract test counts from JSON
            TOTAL=$(jq -r '.numTotalTests // 0' test-results.json 2>/dev/null || echo "0")
            PASSED=$(jq -r '.numPassedTests // 0' test-results.json 2>/dev/null || echo "0")
            FAILED=$(jq -r '.numFailedTests // 0' test-results.json 2>/dev/null || echo "0")
            SKIPPED=$(jq -r '.numPendingTests // 0' test-results.json 2>/dev/null || echo "0")

            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚ùå Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≠Ô∏è Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
            echo "| üìä Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAILED" -gt 0 ]; then
              echo "‚ùå **Tests failed in this shard**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ **All tests passed in this shard**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è Test results file not found for shard ${{ matrix.shard }}" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-e2e-${{ matrix.shard }}
          path: coverage/
          retention-days: 7
          if-no-files-found: ignore
      - name: Save Vitest cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: |
            node_modules/.vite
            node_modules/.vitest
          key: ${{ steps.restore-vitest-cache.outputs.cache-primary-key || format('{0}-vitest-{1}-{2}', runner.os, hashFiles('pnpm-lock.yaml'), github.sha) }}
      - name: Cleanup ephemeral database
        if: always()
        env:
          PGPASSWORD: postgres
        run: |
          if [ -n "${{ env.DB_NAME }}" ]; then
            echo "Dropping ephemeral database: ${{ env.DB_NAME }}"
            psql -h localhost -p 5432 -U postgres -d postgres -c "DROP DATABASE IF EXISTS \"${{ env.DB_NAME }}\";" || true
          fi

  integration-tests:
    name: Integration Tests
    if: needs.changes.outputs.integration == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [changes]
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4]
        total: [4]
    services:
      postgres:
        image: postgres:17
        ports:
          - '5432:5432'
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres -d postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
      - name: Setup pnpm store cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client
      - name: Prepare ephemeral database
        env:
          PGPASSWORD: postgres
        run: |
          # Wait for database readiness
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U postgres -d postgres; then break; fi
            sleep 1
          done

          DB_NAME="ci_${GITHUB_RUN_ID}_integration_${{ matrix.shard }}_${GITHUB_JOB}"
          echo "DB_NAME=${DB_NAME}" >> $GITHUB_ENV
          psql -h localhost -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"${DB_NAME}\";"

          # Defensive bootstrap (idempotent)
          psql -h localhost -p 5432 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 <<'SQL'
          CREATE EXTENSION IF NOT EXISTS pgcrypto;
          DO $$ BEGIN CREATE ROLE anonymous NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE authenticated NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE neondb_owner NOINHERIT NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          CREATE SCHEMA IF NOT EXISTS auth;
          CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb
          LANGUAGE sql
          AS $$ SELECT COALESCE(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb) $$;
          SQL

          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/${DB_NAME}" >> $GITHUB_ENV
      - name: Apply schema with Drizzle
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ env.DATABASE_URL }}
        run: pnpm db:push:test-db
      - name: Grant RLS bypass and role permissions
        env:
          PGPASSWORD: postgres
        run: |
          # Grant BYPASSRLS to postgres user to allow direct test access
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 -c "ALTER ROLE postgres BYPASSRLS;"

          # Grant table permissions to authenticated role for RLS testing
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO authenticated;
          GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
          GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO authenticated;
          SQL

          # Grant read-only permissions to anonymous role
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO anonymous;
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO anonymous;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO anonymous;
          SQL
      - name: Restore Vitest cache
        uses: actions/cache/restore@v4
        id: restore-vitest-cache
        with:
          path: |
            node_modules/.vite
            node_modules/.vitest
          key: ${{ runner.os }}-vitest-${{ hashFiles('pnpm-lock.yaml') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-vitest-${{ hashFiles('pnpm-lock.yaml') }}-
      - name: Run integration tests (shard ${{ matrix.shard }}/${{ matrix.total }})
        # Minimized env to reduce secret exposure; rely on mocks/defaults.
        env:
          NODE_ENV: 'test'
          ALLOW_DB_TRUNCATE: 'true'
          DATABASE_URL: ${{ env.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ env.DATABASE_URL }}
          ENABLE_CURATION: 'false'
        run: |
          set -e
          FILES=$(find tests/integration -type f \( -name "*.test.ts" -o -name "*.spec.ts" -o -name "*.test.tsx" -o -name "*.spec.tsx" \) | wc -l || echo 0)
          if [ "$FILES" -eq 0 ]; then
            echo "No integration test files found; skipping."
            exit 0
          fi
          SHARD=${{ matrix.shard }}
          TOTAL=${{ matrix.total }}
          if [ "$SHARD" -gt "$FILES" ]; then
            echo "Shard $SHARD exceeds file count $FILES; skipping this shard."
            exit 0
          fi
          if [ "$FILES" -lt "$TOTAL" ]; then
            TOTAL="$FILES"
          fi
          pnpm vitest run --project integration tests/integration \
            --shard "$SHARD/$TOTAL" \
            --coverage \
            --coverage.thresholds.lines=0 \
            --coverage.thresholds.functions=0 \
            --coverage.thresholds.branches=0 \
            --coverage.thresholds.statements=0 \
            --reporter=default \
            --reporter=json \
            --outputFile=test-results.json
      - name: Generate test summary
        if: always()
        run: |
          if [ -f test-results.json ]; then
            echo "## üîó Integration Tests - Shard ${{ matrix.shard }}/${{ matrix.total }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Extract test counts from JSON
            TOTAL=$(jq -r '.numTotalTests // 0' test-results.json 2>/dev/null || echo "0")
            PASSED=$(jq -r '.numPassedTests // 0' test-results.json 2>/dev/null || echo "0")
            FAILED=$(jq -r '.numFailedTests // 0' test-results.json 2>/dev/null || echo "0")
            SKIPPED=$(jq -r '.numPendingTests // 0' test-results.json 2>/dev/null || echo "0")

            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚ùå Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≠Ô∏è Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
            echo "| üìä Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAILED" -gt 0 ]; then
              echo "‚ùå **Tests failed in this shard**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ **All tests passed in this shard**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è Test results file not found for shard ${{ matrix.shard }}" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-integration-${{ matrix.shard }}
          path: coverage/
          retention-days: 7
          if-no-files-found: ignore
      - name: Save Vitest cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: |
            node_modules/.vite
            node_modules/.vitest
          key: ${{ steps.restore-vitest-cache.outputs.cache-primary-key || format('{0}-vitest-{1}-{2}', runner.os, hashFiles('pnpm-lock.yaml'), github.sha) }}
      - name: Cleanup ephemeral database
        if: always()
        env:
          PGPASSWORD: postgres
        run: |
          if [ -n "${{ env.DB_NAME }}" ]; then
            echo "Dropping ephemeral database: ${{ env.DB_NAME }}"
            psql -h localhost -p 5432 -U postgres -d postgres -c "DROP DATABASE IF EXISTS \"${{ env.DB_NAME }}\";" || true
          fi

  migration-dry-run:
    name: DB Migration Dry-Run
    needs: [changes]
    if: needs.changes.outputs.migrations == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    services:
      postgres:
        image: postgres:17
        ports:
          - '5432:5432'
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd="pg_isready -U postgres -d postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
      - name: Setup pnpm store cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Install PostgreSQL client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client
      - name: Prepare ephemeral database
        env:
          PGPASSWORD: postgres
        run: |
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U postgres -d postgres; then break; fi
            sleep 1
          done
          DB_NAME="ci_${GITHUB_RUN_ID}_migrate_${GITHUB_JOB}"
          echo "DB_NAME=${DB_NAME}" >> $GITHUB_ENV
          psql -h localhost -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"${DB_NAME}\";"

          # Defensive bootstrap (idempotent)
          psql -h localhost -p 5432 -U postgres -d "${DB_NAME}" -v ON_ERROR_STOP=1 <<'SQL'
          CREATE EXTENSION IF NOT EXISTS pgcrypto;
          DO $$ BEGIN CREATE ROLE anonymous NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE authenticated NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          DO $$ BEGIN CREATE ROLE neondb_owner NOINHERIT NOLOGIN; EXCEPTION WHEN duplicate_object THEN NULL; END $$;
          CREATE SCHEMA IF NOT EXISTS auth;
          CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb
          LANGUAGE sql
          AS $$ SELECT COALESCE(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb) $$;
          SQL

          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/${DB_NAME}" >> $GITHUB_ENV
      - name: Apply migrations (dry-run DB)
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ env.DATABASE_URL }}
        run: pnpm db:migrate:test-db
      - name: Grant RLS bypass and role permissions
        env:
          PGPASSWORD: postgres
        run: |
          # Grant BYPASSRLS to postgres user to allow direct test access
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 -c "ALTER ROLE postgres BYPASSRLS;"

          # Grant table permissions to authenticated role for RLS testing
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO authenticated;
          GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
          GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO authenticated;
          SQL

          # Grant read-only permissions to anonymous role
          psql -h localhost -p 5432 -U postgres -d "${{ env.DB_NAME }}" -v ON_ERROR_STOP=1 <<'SQL'
          GRANT USAGE ON SCHEMA public TO anonymous;
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO anonymous;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO anonymous;
          SQL
      - name: Cleanup ephemeral database
        if: always()
        env:
          PGPASSWORD: postgres
        run: |
          if [ -n "${{ env.DB_NAME }}" ]; then
            echo "Dropping ephemeral database: ${{ env.DB_NAME }}"
            psql -h localhost -p 5432 -U postgres -d postgres -c "DROP DATABASE IF EXISTS \"${{ env.DB_NAME }}\";" || true
          fi

  all-checks-main:
    name: All Checks Passed (main)
    needs: [vulnerability-scan, integration-tests, e2e-tests, migration-dry-run]
    if: always() && (github.event_name == 'push' || github.event_name == 'merge_group')
    runs-on: ubuntu-latest
    steps:
      - name: Check all required jobs succeeded
        run: |
          # Populate results using GitHub Actions expressions at render time
          declare -A results=(
            [vulnerability-scan]="${{ needs.vulnerability-scan.result }}"
            [migration-dry-run]="${{ needs['migration-dry-run'].result }}"
            [integration-tests]="${{ needs['integration-tests'].result }}"
            [e2e-tests]="${{ needs['e2e-tests'].result }}"
          )

          failed=0
          for job in vulnerability-scan migration-dry-run integration-tests e2e-tests; do
            result="${results[$job]}"
            echo "${job} -> ${result}"
            # Treat 'success' as pass; allow 'skipped' (e.g., when changes filter is false)
            if [ "$result" != "success" ] && [ "$result" != "skipped" ]; then
              echo "‚ùå Job '$job' did not succeed (result: $result)"
              failed=1
            fi
          done

          if [ "$failed" -ne 0 ]; then
            exit 1
          fi
      - name: All checks passed (main)
        run: echo "‚úÖ All checks passed (main)"

  trigger-production-deploy:
    name: Deploy to Production
    needs: [all-checks-main, changes]
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.all-checks-main.result == 'success' &&
      needs.changes.outputs.migrations == 'true'
    permissions:
      contents: read
      actions: read
      deployments: write
    uses: ./.github/workflows/deploy-production.yml
    with:
      deploy_migrations: ${{ needs.changes.outputs.migrations == 'true' }}
    secrets: inherit
