name: Deploy - Production

on:
  # Trigger automatically when CI succeeds on main
  workflow_run:
    workflows: ['CI - Main (trunk)']
    types: [completed]
    branches: [main]
  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: read
  actions: read
  deployments: write

concurrency:
  group: deploy-production
  cancel-in-progress: false # Never cancel production deployments

jobs:
  # Gate: Verify CI passed (for workflow_run trigger) or skip (for manual trigger)
  validate-trigger:
    name: Validate Deployment Trigger
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check trigger conditions
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // For manual trigger, always proceed
            if (context.eventName === 'workflow_dispatch') {
              core.info('Manual trigger detected - proceeding with deployment');
              core.setOutput('should_deploy', 'true');
              return;
            }

            // For workflow_run trigger, check if CI passed
            const conclusion = context.payload.workflow_run?.conclusion;
            const workflowName = context.payload.workflow_run?.name;

            core.info(`Triggered by: ${workflowName}`);
            core.info(`CI conclusion: ${conclusion}`);

            if (conclusion === 'success') {
              core.info('CI passed ✅ - proceeding with deployment');
              core.setOutput('should_deploy', 'true');
            } else {
              core.info(`CI did not pass (${conclusion}) - skipping deployment`);
              core.setOutput('should_deploy', 'false');
            }

  # Gate: Verify staging is healthy
  check-staging:
    name: Verify Staging is Healthy
    needs: [validate-trigger]
    if: needs.validate-trigger.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Check staging deployment status
        uses: actions/github-script@v7
        with:
          script: |
            // Check last staging deployment on staging branch
            const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy-staging.yml',
              branch: 'staging',
              status: 'completed',
              per_page: 1
            });

            if (workflows.workflow_runs.length === 0) {
              core.setFailed('No staging deployment found');
              return;
            }

            const lastStagingDeploy = workflows.workflow_runs[0];

            if (lastStagingDeploy.conclusion !== 'success') {
              core.setFailed(`Last staging deployment failed: ${lastStagingDeploy.conclusion}`);
              return;
            }

            core.info(`Last staging deployment passed ✅ (run #${lastStagingDeploy.run_number})`);

  # Step 1: Run database migrations
  migrate-database:
    name: Migrate Database (Production)
    needs: [check-staging]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup pnpm store cache
        uses: actions/cache@v4
        with:
          path: ~/.local/share/pnpm/store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Wake up Neon database
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          echo "Waking up Neon database (may be scaled to zero)..."
          for i in 1 2 3 4 5 6; do
            echo "Attempt $i/6..."
            if node -e "
              const postgres = require('postgres');
              const sql = postgres(process.env.DATABASE_URL, { connect_timeout: 30 });
              sql\`SELECT 1\`.then(() => {
                console.log('Database is ready');
                return sql.end();
              }).then(() => process.exit(0))
              .catch(e => {
                console.error('Not ready:', e.message);
                sql.end().finally(() => process.exit(1));
              });
            "; then
              echo "Database awake and ready"
              exit 0
            fi
            echo "Waiting 10 seconds before retry..."
            sleep 10
          done
          echo "Failed to wake database after 6 attempts"
          exit 1

      - name: Run migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ secrets.DATABASE_URL_NON_POOLING }}
        run: pnpm db:migrate

      - name: Verify migration success
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_URL_NON_POOLING: ${{ secrets.DATABASE_URL_NON_POOLING }}
        run: |
          echo "Production migration completed successfully"
          # Optional: Add a query to verify schema version

  # Step 2: Deploy workers to Fly.io
  deploy-workers:
    name: Deploy Workers (Production)
    needs: [migrate-database]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        include:
          - app: atlaris-worker-prod
            config: fly.prod.worker.toml
            name: Plan Generator
          - app: atlaris-worker-regenerator-prod
            config: fly.prod.regenerator.toml
            name: Plan Regenerator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Deploy ${{ matrix.name }} to Fly.io
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy \
            --config ${{ matrix.config }} \
            --app ${{ matrix.app }} \
            --wait-timeout 300

      - name: Verify deployment
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl status --app ${{ matrix.app }}

  # Note: Next.js deploys automatically via Vercel GitHub integration

  # Final: Report deployment status
  report-status:
    name: Report Deployment Status
    needs: [deploy-workers]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.deploy-workers.result }}" == "success" ]; then
            echo "✅ Production deployment successful"
            exit 0
          else
            echo "❌ Production deployment failed"
            exit 1
          fi
