import { avScannerEnv } from '@/lib/config/env';
import { logger } from '@/lib/logging/logger';
import { heuristicScanProvider } from '@/lib/security/heuristic-scanner';
import { createScanProvider } from '@/lib/security/scanner-factory';
import type { ScanProvider, ScanVerdict } from '@/lib/security/scanner.types';

export type MalwareScanResult = ScanVerdict;

/** Minimal logger interface for DI; callers may pass a full Logger or a mock. */
export interface MalwareScanLogger {
  info(...args: unknown[]): void;
  warn(...args: unknown[]): void;
  error(...args: unknown[]): void;
}

/** Optional context for dependency injection in tests. */
export interface MalwareScanContext {
  heuristicProvider: ScanProvider;
  createScanProvider: () => ScanProvider | null;
  logger: MalwareScanLogger;
  providerCache: { current: ScanProvider | null | undefined };
}

let cachedProvider: ScanProvider | null = null;
let providerInitialized = false;

function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`Scan timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    promise
      .then((result) => {
        clearTimeout(timer);
        resolve(result);
      })
      .catch((err) => {
        clearTimeout(timer);
        reject(err);
      });
  });
}

function getScanProvider(): ScanProvider | null {
  if (providerInitialized) {
    return cachedProvider;
  }
  cachedProvider = createScanProvider();
  providerInitialized = true;
  return cachedProvider;
}

function isValidScanVerdict(obj: unknown): obj is ScanVerdict {
  if (typeof obj !== 'object' || obj === null) return false;
  const o = obj as Record<string, unknown>;
  if (o.clean === true) return true;
  if (o.clean === false && typeof o.threat === 'string') return true;
  return false;
}

function toCanonicalVerdict(obj: unknown): ScanVerdict {
  if (typeof obj !== 'object' || obj === null) {
    return { clean: false, threat: 'Invalid provider response' };
  }
  const o = obj as Record<string, unknown>;
  if (o.clean === true) return { clean: true };
  if (o.clean === false && typeof o.threat === 'string') {
    return { clean: false, threat: o.threat };
  }
  return { clean: false, threat: 'Invalid provider response' };
}

function logScanOutcome(
  scanLogger: MalwareScanLogger,
  params: {
    provider: string;
    fileSize: number;
    result: MalwareScanResult;
    latencyMs: number;
    timedOut?: boolean;
  }
): void {
  const { provider, fileSize, result, latencyMs } = params;
  if (result.clean) {
    scanLogger.info(
      { provider, fileSize, latencyMs, verdict: 'clean' },
      'Malware scan completed'
    );
    return;
  }

  scanLogger.warn(
    {
      provider,
      fileSize,
      latencyMs,
      verdict: 'infected',
      threat: result.threat,
    },
    'Malware scan detected threat'
  );
}

export async function scanBufferForMalware(
  buffer: Buffer,
  context?: MalwareScanContext
): Promise<MalwareScanResult> {
  const startedAt = Date.now();
  const heuristicProvider = context?.heuristicProvider ?? heuristicScanProvider;
  const scanLogger = context?.logger ?? logger;
  let phase: 'heuristic' | 'provider' | null = null;
  let provider: ScanProvider | null = null;

  const getProvider = (): ScanProvider | null => {
    if (context) {
      if (context.providerCache.current !== undefined) {
        return context.providerCache.current;
      }
      context.providerCache.current = context.createScanProvider();
      return context.providerCache.current;
    }
    return getScanProvider();
  };

  try {
    phase = 'heuristic';
    const heuristicResult = await heuristicProvider.scan(buffer);
    const heuristicLatencyMs = Date.now() - startedAt;

    if (!heuristicResult.clean) {
      logScanOutcome(scanLogger, {
        provider: heuristicProvider.name,
        fileSize: buffer.length,
        result: heuristicResult,
        latencyMs: heuristicLatencyMs,
      });
      return heuristicResult;
    }

    provider = getProvider();
    if (!provider) {
      logScanOutcome(scanLogger, {
        provider: 'none',
        fileSize: buffer.length,
        result: heuristicResult,
        latencyMs: heuristicLatencyMs,
      });
      return heuristicResult;
    }

    const timeoutMs = avScannerEnv.scanTimeoutMs;
    let providerResult: MalwareScanResult;
    try {
      phase = 'provider';
      providerResult = await withTimeout(provider.scan(buffer), timeoutMs);
    } catch (err) {
      const latencyMs = Date.now() - startedAt;
      if (err instanceof Error && err.message.includes('timed out')) {
        logScanOutcome(scanLogger, {
          provider: provider.name,
          fileSize: buffer.length,
          result: { clean: false, threat: 'Scan timeout' },
          latencyMs,
          timedOut: true,
        });
      }
      throw err;
    }

    if (!isValidScanVerdict(providerResult)) {
      scanLogger.warn(
        {
          provider: provider.name,
          fileSize: buffer.length,
          rawResult: providerResult,
        },
        'Malware scanner received invalid provider response'
      );
      providerResult = toCanonicalVerdict(providerResult);
    } else {
      providerResult = toCanonicalVerdict(providerResult);
    }

    logScanOutcome(scanLogger, {
      provider: provider.name,
      fileSize: buffer.length,
      result: providerResult,
      latencyMs: Date.now() - startedAt,
    });
    return providerResult;
  } catch (error) {
    scanLogger.error(
      {
        error,
        fileSize: buffer.length,
        phase,
        ...(provider ? { provider: provider.name } : {}),
      },
      'Malware scanner encountered an error'
    );
    throw error;
  }
}
