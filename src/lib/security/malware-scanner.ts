import { logger } from '@/lib/logging/logger';

export type MalwareScanResult =
  | { clean: true }
  | { clean: false; threat: string };

const MAX_SCAN_STRING_BYTES = 5 * 1024 * 1024;
const PDF_MAGIC_BYTES = Buffer.from('%PDF-', 'utf8');
const EICAR_SIGNATURE =
  'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';

const isAsciiAlphaNumeric = (byte: number): boolean => {
  return (
    (byte >= 48 && byte <= 57) ||
    (byte >= 65 && byte <= 90) ||
    (byte >= 97 && byte <= 122)
  );
};

const hasPdfNameToken = (buffer: Buffer, token: string): boolean => {
  let offset = 0;
  while (offset < buffer.length) {
    const index = buffer.indexOf(token, offset, 'latin1');
    if (index === -1) {
      return false;
    }
    const before = index > 0 ? buffer[index - 1] : undefined;
    const after =
      index + token.length < buffer.length
        ? buffer[index + token.length]
        : undefined;
    const beforeOk = before === undefined || !isAsciiAlphaNumeric(before);
    const afterOk = after === undefined || !isAsciiAlphaNumeric(after);
    if (beforeOk && afterOk) {
      return true;
    }
    offset = index + token.length;
  }
  return false;
};

const hasPdfJavaScriptTokens = (content: string): boolean => {
  return (
    /\/JavaScript(?![A-Za-z0-9])/.test(content) ||
    /\/Launch(?![A-Za-z0-9])/.test(content) ||
    /\/JS(?![A-Za-z0-9])/.test(content)
  );
};

/**
 * Scans a buffer for malware/viruses.
 *
 * SECURITY: This is a placeholder with basic signature checks only.
 * @deprecated Replace with ClamAV (clamdscan) or a managed AV service.
 * TODO: Integrate ClamAV via clamdscan/clamd and surface real scan results.
 * TODO: Evaluate a cloud AV fallback (e.g., VirusTotal) for defense-in-depth.
 *
 * @param buffer - The file buffer to scan
 * @returns Promise resolving to scan result with clean status or threat name
 */
export async function scanBufferForMalware(
  buffer: Buffer
): Promise<MalwareScanResult> {
  try {
    const canStringify = buffer.length <= MAX_SCAN_STRING_BYTES;
    const content = canStringify ? buffer.toString('latin1') : null;

    // EICAR standard antivirus test signature
    if (
      (content && content.includes(EICAR_SIGNATURE)) ||
      buffer.indexOf(EICAR_SIGNATURE, 0, 'latin1') !== -1
    ) {
      logger.warn(
        { signature: 'EICAR', size: buffer.length },
        'Malware scan detected EICAR test file'
      );
      return { clean: false, threat: 'EICAR-Test-File' };
    }

    // PDF with JavaScript/Launch actions (potential exploit vector)
    const isPdf =
      buffer.length >= PDF_MAGIC_BYTES.length &&
      buffer.subarray(0, 5).equals(PDF_MAGIC_BYTES);
    // Heuristic: look for explicit PDF name tokens to reduce false positives.
    const hasJsTokens = content
      ? hasPdfJavaScriptTokens(content)
      : hasPdfNameToken(buffer, '/JavaScript') ||
        hasPdfNameToken(buffer, '/Launch') ||
        hasPdfNameToken(buffer, '/JS');
    if (isPdf && hasJsTokens) {
      logger.warn(
        { signature: 'PDF-JavaScript', size: buffer.length },
        'Malware scan detected JavaScript in PDF'
      );
      return { clean: false, threat: 'PDF-JavaScript-Suspicious' };
    }

    logger.debug({ size: buffer.length }, 'Malware scan completed - clean');
    return { clean: true };
  } catch (error) {
    logger.error(
      { error, size: buffer.length },
      'Malware scanner encountered an error'
    );
    throw error;
  }
}
