import { beforeEach, describe, expect, it, vi } from 'vitest';

import {
  createScanProvider,
  resetScanProviderCache,
} from '@/lib/security/scanner-factory';
import {
  scanBufferForMalware,
  type MalwareScanContext,
} from '@/lib/security/malware-scanner';
import { heuristicScanProvider } from '@/lib/security/heuristic-scanner';
import type { ScanProvider, ScanVerdict } from '@/lib/security/scanner.types';

import {
  createCleanPdfBuffer,
  createSuspiciousJsPdfBuffer,
} from '../../../fixtures/security/malicious-buffers';

const originalAvProvider = process.env.AV_PROVIDER;
const originalAvTimeout = process.env.AV_SCAN_TIMEOUT_MS;
const originalAvApiKey = process.env.AV_METADEFENDER_API_KEY;

const createContext = (providerFactory: () => ScanProvider | null) => {
  const logger = {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  };

  const context: MalwareScanContext = {
    heuristicProvider: heuristicScanProvider,
    createScanProvider: providerFactory,
    logger,
    providerCache: { current: undefined },
  };

  return { context, logger };
};

describe('malware scanner light integration', () => {
  beforeEach(() => {
    resetScanProviderCache();
    process.env.AV_PROVIDER = originalAvProvider;
    process.env.AV_SCAN_TIMEOUT_MS = originalAvTimeout;
    process.env.AV_METADEFENDER_API_KEY = originalAvApiKey;
  });

  it('short-circuits on heuristic threats before provider creation', async () => {
    const providerFactory = vi.fn<() => ScanProvider | null>(() => {
      throw new Error('Provider should not be created for heuristic threats');
    });
    const { context } = createContext(providerFactory);

    const result = await scanBufferForMalware(
      createSuspiciousJsPdfBuffer(),
      context
    );

    expect(result).toEqual({
      clean: false,
      threat: 'PDF-JavaScript-Suspicious',
    });
    expect(providerFactory).not.toHaveBeenCalled();
  });

  it('normalizes malformed provider responses to an explicit threat', async () => {
    const providerFactory = vi.fn<() => ScanProvider | null>(() => ({
      name: 'mock-provider',
      scan: vi.fn(async () => ({ foo: 'bar' }) as unknown as ScanVerdict),
    }));
    const { context, logger } = createContext(providerFactory);

    const result = await scanBufferForMalware(createCleanPdfBuffer(), context);

    expect(result).toEqual({
      clean: false,
      threat: 'Invalid provider response',
    });
    expect(logger.warn).toHaveBeenCalledWith(
      expect.objectContaining({ provider: 'mock-provider' }),
      'Malware scanner received invalid provider response'
    );
  });

  it('fails closed when provider scan hangs beyond timeout', async () => {
    process.env.AV_SCAN_TIMEOUT_MS = '5';

    const providerFactory = vi.fn<() => ScanProvider | null>(() => ({
      name: 'hanging-provider',
      scan: vi.fn(() => new Promise<never>(() => {})),
    }));
    const { context } = createContext(providerFactory);

    await expect(
      scanBufferForMalware(createCleanPdfBuffer(), context)
    ).rejects.toThrow('Scan timed out after 1000ms');
  });

  it('returns null provider when AV_PROVIDER=none in test runtime', () => {
    process.env.AV_PROVIDER = 'none';
    resetScanProviderCache();

    expect(createScanProvider()).toBeNull();
    expect(createScanProvider()).toBeNull();
  });

  it('creates a MetaDefender provider when env is configured', () => {
    process.env.AV_PROVIDER = 'metadefender';
    process.env.AV_METADEFENDER_API_KEY = 'test-api-key';
    resetScanProviderCache();

    const provider = createScanProvider();

    expect(provider?.name).toBe('metadefender');
  });
});
