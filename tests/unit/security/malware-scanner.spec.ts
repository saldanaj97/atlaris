import { beforeEach, describe, expect, it, vi } from 'vitest';

import {
  scanBufferForMalware,
  type MalwareScanContext,
} from '@/lib/security/malware-scanner';
import type { ScanProvider, ScanVerdict } from '@/lib/security/scanner.types';
import {
  createCleanPdfBuffer,
  createSuspiciousJsPdfBuffer,
} from '../../fixtures/security/malicious-buffers';

type LoggerMock = {
  info: ReturnType<typeof vi.fn>;
  warn: ReturnType<typeof vi.fn>;
  error: ReturnType<typeof vi.fn>;
  debug: ReturnType<typeof vi.fn>;
};

type Harness = {
  scanBufferForMalware: (buffer: Buffer) => Promise<ScanVerdict>;
  heuristicScan: ReturnType<
    typeof vi.fn<(buffer: Buffer) => Promise<ScanVerdict>>
  >;
  createScanProvider: ReturnType<typeof vi.fn<() => ScanProvider | null>>;
  providerScan: ReturnType<
    typeof vi.fn<(buffer: Buffer) => Promise<ScanVerdict>>
  >;
  logger: LoggerMock;
};

type HarnessOptions = {
  heuristicResult: ScanVerdict;
  providerResult?: ScanVerdict;
  providerError?: Error;
  providerAvailable?: boolean;
  providerName?: string;
};

const makeLoggerMock = (): LoggerMock => ({
  info: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
  debug: vi.fn(),
});

const loadHarness = (options: HarnessOptions): Harness => {
  const heuristicScan = vi
    .fn<(buffer: Buffer) => Promise<ScanVerdict>>()
    .mockResolvedValue(options.heuristicResult);

  const providerScan = vi.fn<(buffer: Buffer) => Promise<ScanVerdict>>();
  if (options.providerError) {
    providerScan.mockRejectedValue(options.providerError);
  } else {
    providerScan.mockResolvedValue(options.providerResult ?? { clean: true });
  }

  const providerName = options.providerName ?? 'metadefender';
  const createScanProvider = vi.fn<() => ScanProvider | null>(() => {
    if (options.providerAvailable === false) {
      return null;
    }
    return {
      name: providerName,
      scan: providerScan,
    };
  });

  const logger = makeLoggerMock();
  const providerCache = {
    current: undefined as ScanProvider | null | undefined,
  };

  const heuristicProvider: ScanProvider = {
    name: 'heuristic',
    scan: heuristicScan,
  };

  const context: MalwareScanContext = {
    heuristicProvider,
    createScanProvider,
    logger,
    providerCache,
  };

  return {
    scanBufferForMalware: (buffer: Buffer) =>
      scanBufferForMalware(buffer, context),
    heuristicScan,
    createScanProvider,
    providerScan,
    logger,
  };
};

describe('malware-scanner orchestrator', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns heuristic clean result when no external provider is configured', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerAvailable: false,
    });

    const result = await harness.scanBufferForMalware(createCleanPdfBuffer());

    expect(result).toEqual({ clean: true });
    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).not.toHaveBeenCalled();
    expect(harness.logger.info).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: 'none',
        verdict: 'clean',
        latencyMs: expect.any(Number),
      }),
      'Malware scan completed'
    );
  });

  it('short-circuits when heuristic scanner finds a threat', async () => {
    const harness = loadHarness({
      heuristicResult: {
        clean: false,
        threat: 'PDF-JavaScript-Suspicious',
      },
    });

    const result = await harness.scanBufferForMalware(
      createSuspiciousJsPdfBuffer()
    );

    expect(result).toEqual({
      clean: false,
      threat: 'PDF-JavaScript-Suspicious',
    });
    expect(harness.createScanProvider).not.toHaveBeenCalled();
    expect(harness.providerScan).not.toHaveBeenCalled();
    expect(harness.logger.warn).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: 'heuristic',
        verdict: 'infected',
        threat: 'PDF-JavaScript-Suspicious',
        latencyMs: expect.any(Number),
      }),
      'Malware scan detected threat'
    );
  });

  it('returns provider threat verdict when external scanner flags malware', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerResult: { clean: false, threat: 'MetaDefender-Infected' },
    });

    const result = await harness.scanBufferForMalware(createCleanPdfBuffer());

    expect(result).toEqual({
      clean: false,
      threat: 'MetaDefender-Infected',
    });
    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).toHaveBeenCalledTimes(1);
    expect(harness.logger.warn).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: 'metadefender',
        verdict: 'infected',
        threat: 'MetaDefender-Infected',
        latencyMs: expect.any(Number),
      }),
      'Malware scan detected threat'
    );
  });

  it('propagates provider errors for fail-closed handling upstream', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerError: new Error('MetaDefender unavailable'),
    });

    await expect(
      harness.scanBufferForMalware(createCleanPdfBuffer())
    ).rejects.toThrow('MetaDefender unavailable');

    expect(harness.logger.error).toHaveBeenCalledWith(
      expect.objectContaining({
        fileSize: expect.any(Number),
        error: expect.any(Error),
      }),
      'Malware scanner encountered an error'
    );
  });

  it('creates the provider lazily and reuses it across scans', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerResult: { clean: true },
    });
    const buffer = createCleanPdfBuffer();

    await harness.scanBufferForMalware(buffer);
    await harness.scanBufferForMalware(buffer);

    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).toHaveBeenCalledTimes(2);
  });

  it('propagates provider error on mid-session failure and logs error', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerResult: { clean: true },
    });
    const providerError = new Error('Provider failed mid-session');
    harness.providerScan
      .mockResolvedValueOnce({ clean: true })
      .mockRejectedValueOnce(providerError);

    const buffer = createCleanPdfBuffer();

    const firstResult = await harness.scanBufferForMalware(buffer);
    expect(firstResult).toEqual({ clean: true });

    await expect(harness.scanBufferForMalware(buffer)).rejects.toThrow(
      'Provider failed mid-session'
    );

    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).toHaveBeenCalledTimes(2);
    expect(harness.logger.error).toHaveBeenCalledWith(
      expect.objectContaining({
        fileSize: expect.any(Number),
        error: expect.any(Error),
      }),
      'Malware scanner encountered an error'
    );
  });

  it('handles empty buffer via heuristic path and logs appropriately', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
      providerResult: { clean: true },
    });

    const result = await harness.scanBufferForMalware(Buffer.from(''));

    expect(result).toEqual({ clean: true });
    expect(harness.heuristicScan).toHaveBeenCalledWith(Buffer.from(''));
    expect(harness.heuristicScan).toHaveBeenCalledTimes(1);
    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).toHaveBeenCalledTimes(1);
    expect(harness.logger.info).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: 'metadefender',
        verdict: 'clean',
        fileSize: 0,
        latencyMs: expect.any(Number),
      }),
      'Malware scan completed'
    );
  });

  it('normalizes malformed provider result and logs warning', async () => {
    const harness = loadHarness({
      heuristicResult: { clean: true },
    });
    harness.providerScan
      .mockResolvedValueOnce({
        clean: true,
        threat: undefined,
      } as unknown as ScanVerdict)
      .mockResolvedValueOnce({ foo: 'bar' } as unknown as ScanVerdict);

    const firstResult = await harness.scanBufferForMalware(
      createCleanPdfBuffer()
    );
    expect(firstResult).toEqual({ clean: true });

    const secondResult = await harness.scanBufferForMalware(
      createCleanPdfBuffer()
    );
    expect(secondResult).toEqual({
      clean: false,
      threat: 'Invalid provider response',
    });

    expect(harness.createScanProvider).toHaveBeenCalledTimes(1);
    expect(harness.providerScan).toHaveBeenCalledTimes(2);
    expect(harness.logger.warn).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: 'metadefender',
        fileSize: expect.any(Number),
        rawResult: { foo: 'bar' },
      }),
      'Malware scanner received invalid provider response'
    );
  });
});
